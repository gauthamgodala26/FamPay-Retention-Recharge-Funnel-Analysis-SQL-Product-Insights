# Retention & Transaction Metrics — SQL Queries

This repository-ready markdown contains SQL files you can copy-paste directly into a GitHub repo. Each metric has:

* A heading and short description
* Suggested file name
* Ready-to-paste, formatted SQL (Postgres-flavored)

---

## Repo layout (suggested)

```
sql/
  metric_01_avg_transactions.sql
  metric_02_days_to_first_txn.sql
  metric_03_txn_type_distribution.sql
  metric_04_txn_value_stats.sql
  metric_05_age_group_distribution.sql
  metric_06_avg_active_months.sql
  metric_07_txn_type_diversity.sql
README.md
```

---

## Notes / assumptions

* SQL is written for PostgreSQL (uses `date_trunc` and interval arithmetic).
* Tables used:

  * `transaction_details` (columns used: `user_id`, `date_of_transaction`, `status`, `type_of_transaction`, `amount`)
  * `user_details` (columns used: `user_id`, `activation_date`, `age`)
* `Retention` definition: a user is **Retained** if they have transactions in **3 or more distinct months** (as in your original logic). Otherwise `Not Retained`.
* All queries restrict to `status = 'Completed'` unless otherwise noted.

---

# Metric 1 — Avg. transactions per month (Retained vs Not Retained)

**File:** `sql/metric_01_avg_transactions.sql`

```sql
-- Metric 1: Avg. transactions per user (grouped by Retained / Not Retained)
WITH user_retention AS (
  SELECT
    user_id,
    CASE WHEN COUNT(DISTINCT date_trunc('month', date_of_transaction)) >= 3
         THEN 'Retained' ELSE 'Not Retained' END                     AS retention_status,
    COUNT(*) AS txn_count
  FROM transaction_details
  WHERE status = 'Completed'
  GROUP BY user_id
)

SELECT
  retention_status,
  ROUND(AVG(txn_count)::numeric, 2) AS avg_transactions_per_user
FROM user_retention
GROUP BY retention_status
ORDER BY retention_status;
```

---

# Metric 2 — Average time between activation and first transaction

**File:** `sql/metric_02_days_to_first_txn.sql`

```sql
-- Metric 2: days between activation_date and first completed transaction
WITH first_txn AS (
  SELECT
    td.user_id,
    MIN(td.date_of_transaction) AS first_transaction_date
  FROM transaction_details td
  WHERE td.status = 'Completed'
  GROUP BY td.user_id
),
user_retention AS (
  SELECT
    td.user_id,
    CASE WHEN COUNT(DISTINCT date_trunc('month', td.date_of_transaction)) >= 3
         THEN 'Retained' ELSE 'Not Retained' END AS retention_status
  FROM transaction_details td
  WHERE td.status = 'Completed'
  GROUP BY td.user_id
)

SELECT
  ur.retention_status,
  ROUND(AVG(EXTRACT(EPOCH FROM (ft.first_transaction_date - ud.activation_date)) / 86400)::numeric, 2) AS avg_days_to_first_txn
FROM user_details ud
JOIN first_txn ft ON ud.user_id = ft.user_id
JOIN user_retention ur ON ud.user_id = ur.user_id
GROUP BY ur.retention_status
ORDER BY ur.retention_status;
```

*Notes*: this uses `EXTRACT(EPOCH FROM interval)/86400` to get fractional days. If you prefer integer days, wrap with `FLOOR(...)` or cast to `INT`.

---

# Metric 3 — Transaction type distribution (Merchant vs P2P vs Card)

**File:** `sql/metric_03_txn_type_distribution.sql`

```sql
-- Metric 3: distribution of transactions by type, within each retention group
WITH user_retention AS (
  SELECT
    user_id,
    CASE WHEN COUNT(DISTINCT date_trunc('month', date_of_transaction)) >= 3
         THEN 'Retained' ELSE 'Not Retained' END AS retention_status
  FROM transaction_details
  WHERE status = 'Completed'
  GROUP BY user_id
)

SELECT
  ur.retention_status,
  td.type_of_transaction,
  COUNT(*) AS txn_count,
  CONCAT(ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (PARTITION BY ur.retention_status), 2), '%') AS percentage_share
FROM transaction_details td
JOIN user_retention ur ON td.user_id = ur.user_id
WHERE td.status = 'Completed'
GROUP BY ur.retention_status, td.type_of_transaction
ORDER BY ur.retention_status, txn_count DESC;
```

---

# Metric 4 — Avg, Min, Max transaction value

**File:** `sql/metric_04_txn_value_stats.sql`

```sql
-- Metric 4: transaction value stats per retention cohort
WITH user_retention AS (
  SELECT
    user_id,
    CASE WHEN COUNT(DISTINCT date_trunc('month', date_of_transaction)) >= 3
         THEN 'Retained' ELSE 'Not Retained' END AS retention_status
  FROM transaction_details
  WHERE status = 'Completed'
  GROUP BY user_id
)

SELECT
  ur.retention_status,
  ROUND(AVG(td.amount)::numeric, 2)    AS avg_txn_value,
  MAX(td.amount)                       AS max_txn_value,
  MIN(td.amount)                       AS min_txn_value
FROM transaction_details td
JOIN user_retention ur ON td.user_id = ur.user_id
WHERE td.status = 'Completed'
GROUP BY ur.retention_status
ORDER BY ur.retention_status;
```

---

# Metric 5 — Age group distribution (Teens, Young Adults, Adults)

**File:** `sql/metric_05_age_group_distribution.sql`

```sql
-- Metric 5: user count by age bucket and retention cohort
WITH user_retention AS (
  SELECT
    user_id,
    CASE WHEN COUNT(DISTINCT date_trunc('month', date_of_transaction)) >= 3
         THEN 'Retained' ELSE 'Not Retained' END AS retention_status
  FROM transaction_details
  WHERE status = 'Completed'
  GROUP BY user_id
)

SELECT
  ur.retention_status,
  CASE
    WHEN ud.age BETWEEN 13 AND 17 THEN 'Teen (13-17)'
    WHEN ud.age BETWEEN 18 AND 21 THEN 'Young Adult (18-21)'
    WHEN ud.age BETWEEN 22 AND 25 THEN 'Adult (22-25)'
    ELSE 'Other'
  END AS age_bucket,
  COUNT(*) AS user_count
FROM user_details ud
JOIN user_retention ur ON ud.user_id = ur.user_id
GROUP BY ur.retention_status, age_bucket
ORDER BY ur.retention_status, user_count DESC;
```

*Note*: If your `user_details.age` is nullable or computed from a `date_of_birth`, compute age first (e.g. `DATE_PART('year', age(current_date, dob))`).

---

# Metric 6 — Average active months (Retained vs Not Retained)

**File:** `sql/metric_06_avg_active_months.sql`

```sql
-- Metric 6: average number of active months per user in each retention cohort
WITH active_months AS (
  SELECT
    user_id,
    COUNT(DISTINCT date_trunc('month', date_of_transaction)) AS active_months
  FROM transaction_details
  WHERE status = 'Completed'
  GROUP BY user_id
),
retention_status AS (
  SELECT
    user_id,
    CASE WHEN COUNT(DISTINCT date_trunc('month', date_of_transaction)) >= 3
         THEN 'Retained' ELSE 'Not Retained' END AS retention_status
  FROM transaction_details
  WHERE status = 'Completed'
  GROUP BY user_id
)

SELECT
  rs.retention_status,
  ROUND(AVG(am.active_months)::numeric, 2) AS avg_active_months
FROM retention_status rs
JOIN active_months am ON rs.user_id = am.user_id
GROUP BY rs.retention_status
ORDER BY rs.retention_status;
```

---

# Metric 7 — Transaction type diversity (Single vs Multi-type users)

**File:** `sql/metric_07_txn_type_diversity.sql`

```sql
-- Metric 7: percentage of users who transact with multiple transaction types
WITH retention_status AS (
  SELECT
    user_id,
    CASE WHEN COUNT(DISTINCT date_trunc('month', date_of_transaction)) >= 3
         THEN 'Retained' ELSE 'Not Retained' END AS retention_status
  FROM transaction_details
  WHERE status = 'Completed'
  GROUP BY user_id
),

txn_type AS (
  SELECT
    user_id,
    COUNT(DISTINCT type_of_transaction) AS txn_type_count
  FROM transaction_details
  WHERE status = 'Completed'
  GROUP BY user_id
)

SELECT
  rs.retention_status,
  SUM(CASE WHEN tt.txn_type_count >= 2 THEN 1 ELSE 0 END) AS multiple_type_users,
  COUNT(*) AS total_users,
  CONCAT(ROUND(100.0 * SUM(CASE WHEN tt.txn_type_count >= 2 THEN 1 ELSE 0 END) / COUNT(*) , 2), '%') AS pct_multiple_type_users
FROM retention_status rs
JOIN txn_type tt ON rs.user_id = tt.user_id
GROUP BY rs.retention_status
ORDER BY rs.retention_status;
```

---

## Extra tips

* If your dataset is large, run `EXPLAIN ANALYZE` and add indexes on `transaction_details(user_id, status, date_of_transaction)` and `user_details(user_id)` to speed up the aggregation queries.
* If you want these queries as `.sql` files in the repo, copy each code block into the corresponding file name from the suggested layout.

---

Happy to also:

* convert these into parameterized views or materialized views
* wrap them into a single SQL file that outputs all metrics together
* generate sample output / dummy data for quick testing
